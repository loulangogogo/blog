[toc]

## 概述

> Software entities like classes, modules and functions should be open for extension but closed for modifications.(一个软件实体如类、模块和函数应该对扩展开放，对修改关闭)

**请注意开闭原则的实体：**

- 项目获软件产品中按照一定的逻辑规则划分的模块
- 抽象和类
- 方法



> 开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，底层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。

&emsp;&emsp;***开闭原则是非常重要的，是六个原则中最基础的一个原则，是精神领袖般的存在。换一种说法，按照java语言的称谓，开闭原则就是抽象类，而其他五大原则就是具体的实现类。***

## 什么是开闭原则

&emsp;&emsp;其实在概述中我已经描述了开闭原则，接下来用举例来说明一下。

```java
/*********************************************************
 ** 测试开闭原则
 ** <br><br>
 ** Date: Created in 2024/7/9 22:22
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
public class TestKB {
    public static void main(String[] args) {
        Iuser user = new User("loulan", "1234567890");

        // 获取用户的手机号码
        System.out.println(user.getPhone()); // 1234567890
    }
}


/*********************************************************
 ** 用户接口实现类
 ** <br><br>
 ** Date: Created in 2024/7/9 22:28
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
class User implements Iuser{
    // 用户名
    private String name;
    // 用户手机号
    private String phone;

    // 构造函数构造对象
    public User(String name, String phone) {
        this.name = name;
        this.phone = phone;
    }

    // 获取用户名
    @Override
    public String getName() {
        return name;
    }

    // 获取用户手机号
    @Override
    public String getPhone() {
        return phone;
    }
}

/*********************************************************
 ** 用户接口
 ** <br><br>
 ** Date: Created in 2024/7/9 22:28
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
interface Iuser{
    // 获取姓名
    public String getName();
    // 获取手机号
    public String getPhone();
}

```

&emsp;&emsp;从这个案例中我们可以看到，主要是创建用户和获取用户的手机号码并进行打印，这是我们在开发中很常见的一个场景。

&emsp;&emsp;一天，根据隐私要求产品要求所有的手机号都要进行脱敏展示，这个时候我们有如下几种解决方案：

- **修改接口**

&emsp;&emsp;在 Iuser 接口上新增一个方法 getMaskPhone()，专门用于获取脱敏的手机号码，所有的实现类都要实现该方法。但是这样操作的后果就是所有实现类 (目前就一个，实际项目可能很多) 的修改，main方法也要修改；这样操作的影响太大，Iuser 作为接口应该是稳定可靠的，不应该经常的发生变化，否则作为接口的契约作用就失效了。所以，**该方案否定**。

- **修改实现类**

&emsp;&emsp;修改实现类首先不能是添加一个脱敏方法，为什么呢？因为我们实例化的时候，虽然是 User，然而变量是父级接口 Iuser，这样就会导致方法找不到，除非将变量也修改为 User，但是这样就失去了接口Iuser的作用了，并不提倡这样操作。

&emsp;&emsp;另外的一个方式就是修改 getPhone() 方法了，直接在方法里面进行脱敏，这样其他的什么都不用修改就可以达到脱敏的效果了。但是我们要注意的问题是，User 对象的使用可能并不是只有这一个地方使用，有些地方可能还是需要获取真实的手机号码进行发送短信，或者登陆匹配等等这样的操作。一旦在 getPhone() 方法里面进行了脱敏，导致无法获取真实的手机号码，带来的bug也是很严重的。所以，**该方案也不是最优的**。

- **通过扩展实现变化**

&emsp;&emsp;通过扩展 User 类来实现，可以新增一个 PhoneMaskUser 类来继承 User 类，并重写方法 getPhone() ,这样只需要在需要脱敏的地方将 User 对象替换为 PhoneMaskUser 就可以了，还不会影响到原来正常使用 User 类的方法。



**新增的类方法和修改如下：**

```java
/*********************************************************
 ** 测试开闭原则
 ** <br><br>
 ** Date: Created in 2024/7/9 22:22
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
public class TestKB {
    public static void main(String[] args) {
      
      	// 这里的实例化类修改
        Iuser user = new PhoneMaskUser("loulan", "1234567890");

        // 获取用户的手机号码
        System.out.println(user.getPhone()); // 123****7890
    }
}

/*********************************************************
 ** 手机号吗脱敏的用户
 ** <br><br>
 ** Date: Created in 2024/7/9 23:03
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
class PhoneMaskUser extends User{
    public PhoneMaskUser(String name, String phone) {
        super(name, phone);
    }

    @Override
    public String getPhone() {
        // 手机号码脱敏的方法
        return StrTool.dataMasking(super.getPhone(), MaskingDataTypeEnum.PHONE);
    }
}
```

&emsp;&emsp;这样我们就可以安全、稳定、高效的实现手机号码脱敏的需求。这就是开闭原则的一个简单应用，对类的扩展开放，对修改关闭。

## 为什么使用开闭原则

1. **开闭原则对测试的影响**

   &emsp;&emsp;所有已经投产的代码都是有意义的，并且都受系统规则的约束，这样的代码都要经过“千锤百炼”的测试过程，不仅保证逻辑是正确的，还要保证苛刻条件（高压力、异常、错误）下不产生“有毒代码”（Poisonous Code），因此有变化提出时，我们就需要考虑一下，原有的健壮代码是否可以不修改，仅仅通过扩展实现变化呢？否则，就需要把原有的测试过程回笼一遍，需要进行单元测试、功能测试、集成测试甚至是验收测试，现在虽然在大力提倡自动化测试工具，但是仍然代替不了人工的测试工作。

   &emsp;&emsp;测试的过程中我们要进行各种复杂的业务逻辑测试、边界条件的测试、异常测试等等，使用开闭原则，我们可以增加扩展对应的实现类来达到不能业务逻辑、功能的测试，就会将单元测试变得简单很多。

   

2. **开闭原则可以提高复用性**

   &emsp;&emsp;在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。那为什么要复用呢？减少代码量，避免相同的逻辑分散在多个角落，避免日后的维护人员为了修改一个微小的缺陷或增加新功能而要在整个项目中到处查找相关的代码，然后发出对开发人员“极度失望”的感慨。那怎么才能提高复用率呢？缩小逻辑粒度，直到一个逻辑不可再拆分为止。

   

3. **开闭原则可以提高可复用性**

   &emsp;&emsp;一款软件投产后，维护人员的工作不仅仅是对数据进行维护，还可能要对程序进行扩展，维护人员最乐意做的事情就是扩展一个类，而不是修改一个类，甭管原有的代码写得多么优秀还是多么糟糕，让维护人员读懂原有的代码，然后再修改，是一件很痛苦的事情，不要让他在原有的代码海洋里游弋完毕后再修改，那是对维护人员的一种折磨和摧残。

   

4. **面向对象的开发要求**

   &emsp;&emsp;万物皆对象，我们需要把所有的事物都抽象成对象，然后针对对象进行操作，但是万物皆运动，有运动就有变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。

   

## 如何使用开闭原则

1. **抽象约束**
   &emsp;&emsp;抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：

   - **通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；**
   - **参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；**
   - **抽象层尽量保持稳定，一旦确定即不允许修改。**

   

   &emsp;&emsp;这三层含义或者说是要求，尤其在比较复杂的大项目上，可以保证项目的稳定和方便后期的维护。上面代码案例中：

   - 如果 User 这个实现类随便在其中添加方法，其父级接口是无法使用的，因为接口已经进行了边界限定；
   - 如果 main 方法的是实例化对象的参数类型、应用对象没有使用接口，后期它的实例对象由 User 切换为 PhoneMaskUser 的时候就不那么容易了。
   - 如果 Iuser 接口，如果在生产后期对其进行随便的添加方法，就会导致实现类大批量的错误；

2. **元数据控制模块行为**
   ‌&emsp;&emsp;元数据可以用来定义和控制模块的行为，‌包括模块的启动、‌停止、‌配置等。‌通过使用元数据，‌可以在不修改源代码的情况下，‌改变模块的运行时行为，‌从而满足新的需求。‌这种方式的优点在于，‌它允许在不破坏现有功能的前提下，‌灵活地扩展系统的功能，‌提高了系统的可维护性和可扩展性。‌

   &emsp;&emsp;例如，‌在Spring框架中，‌元数据被广泛用于控制模块的行为。‌通过配置文件或注解的方式，‌开发者可以定义模块之间的依赖关系、‌行为等，‌而无需修改源代码。‌这种方式不仅提高了开发效率，‌也使得系统更加灵活和可维护。‌

3. **指定项目的章程**
&emsp;&emsp;在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。相信大家都做过项目，会发现一个项目会产生非常多的配置文件。举个简单的例子，以SSH项目开发为例，一个项目中的Bean配置文件就非常多，管理非常麻烦。如果需要扩展，就需要增加子类，并修改SpringContext文件。然而，如果你在项目中指定这样一个章程：所有的Bean都自动注入，使用Annotation进行装配，进行扩展时，甚至只用写一个子类，然后由持久层生成对象，其他的都不需要修改，这就需要项目内约束，每个项目成员都必须遵守，该方法需要一个团队有较高的自觉性，需要一个较长时间的磨合，一旦项目成员都熟悉这样的规则，比通过接口或抽象类进行约束效率更高，而且扩展性一点也没有减少。

4. **封装变化**
&emsp;&emsp;对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。封装变化，也就是受保护的变化，找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，一旦预测到或“第六感”发觉有变化，就可以进行封装。
