# 依赖倒置原则

## 什么是依赖倒置原则

> High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.
>
> - 高层模块不应该依赖底层模块，两者都应该依赖其抽象.
> - 抽象不应该依赖细节。
> - 细节应该依赖抽象。



&emsp;&emsp;通过 java 来体现就是 **“面向接口编程”**，其表现就是：

- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的。
- 接口或者抽象类不依赖于实现类。
- 实现类依赖接口或者抽象类。

​	

**依赖倒置原则的本质就是通过抽象（接口或者抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。**



## 为什么使用依赖倒置

- 减少类之间的耦合性
- 提高系统的稳定性
- 降低并行开发引起的风险。
- 提高代码的可读性和可维护性。



&emsp;&emsp;如下我们来看个使用案例：

```java
package io.github.loulangogogo.test02;

/*********************************************************
 ** 测试依赖倒置原则
 ** <br><br>
 ** Date: Created in 2024/7/14 22:47
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
public class TestYL {

    public static void main(String[] args) {
        Isolider solider = new LuSolider();
        solider.killEnemy(new AK47());
    }
}

/*********************************************************
 ** 定义一个枪的接口
 ** <br><br>
 ** Date: Created in 2024/7/14 22:47
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
interface Igun{

    // 枪的设计功能
    public void shoot();
}

/*********************************************************
 ** 定义一个士兵接口
 ** <br><br>
 ** Date: Created in 2024/7/14 22:48
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
interface Isolider{
    // 使用武器射杀敌人
    public void killEnemy(Igun gun);
}

/*********************************************************
 ** 定义一个AK47
 ** <br><br>
 ** Date: Created in 2024/7/14 22:51
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
class AK47 implements Igun{
    @Override
    public void shoot() {
        System.out.println("AK47 shoot");
    }
}

/*********************************************************
 ** 定义一个陆军
 ** <br><br>
 ** Date: Created in 2024/7/14 22:51
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
class LuSolider implements Isolider{
    @Override
    public void killEnemy(Igun gun) {
        gun.shoot();
    }
}

```

&emsp;&emsp;通过这个案例我们可以看到如下几点：

1. 士兵使用枪支是通过接口来实现的，这样两个类之间的开发就降低了耦合性。
2. 而且先定义好枪支的接口，这样士兵类和枪支实现类就可以并行开发。
3. 程序员可以直接通过接口来阅读代码的整体大概逻辑，提高可读性。同时后期的修改调整只需要通过修改单个实现类或者新增接口实现类就可以，这样对代码整体影响范围会很小。
4. 比如我们士兵有的使用的是AUG狙击枪，我们只需要新增狙击枪的实现类就可以了，不需要对接口或者其他实现类进行修改。

```java
/*********************************************************
 ** 测试依赖倒置原则
 ** <br><br>
 ** Date: Created in 2024/7/14 22:47
 ** @author loulan
 ** @version 0.0.0
 *********************************************************/
public class TestYL {

    public static void main(String[] args) {
        Isolider solider = new LuSolider();
        solider.killEnemy(new AK47());
        solider.killEnemy(new AUG());
    }
}

/*********************************************************
 ** AUG狙击枪实现类
 ** <br><br>
 ** Date: Created in 2024/7/14 23:01
 ** @author loulan
 ** @version 0.0.0‘
 *********************************************************/
class AUG implements Igun{

    @Override
    public void shoot() {
        System.out.println("AUG shoot");
    }
}
```

&emsp;&emsp;通过这种方式我们可以很轻松的扩展枪械的类型，而不需要对其他的实现类造成风险。





## 怎么使用依赖倒置

&emsp;&emsp;通过上面的案例，我们应该已经有了一个基本的使用概念，接下来具体总结一下如何去使用这个依赖倒置：

##### 1. 每个类尽量都有接口或抽象类，或者两者都有。

&emsp;&emsp;这个是依赖倒置原则的基本要求，接口和抽象类都属于抽象的，有了抽象才有可能实现依赖倒置。



##### 2. 变量的表面类型尽量是接口或者抽象类。

&emsp;&emsp;这里说了是 尽量，不是一定，也就是说有些类也不一定非得有抽象类或者接口，比如说工具类 xxxUtils 等等。但是如果可以的话尽量还是有接口和抽象类。



##### 3. 任何类都不应该从具体类派生

&emsp;&emsp;按照理想的项目开发来说，并且要实现依赖倒置，确实任何类都不应该从具体类进行派生，应该是从接口或者抽象类来进行派生。但是这也不是绝对的，为什么呢？在很多项目的后期维护过程中，基本上很多都是针对类进行扩展开发维护，因为通过简单的扩展就可以维护 bug 了，没有必要重新实现最高接口或者抽象类来操作。

&emsp;&emsp;不过在开发过程中还是尽量不要从具体类去进行派生，尤其是项目处于初始开发阶段。



##### 4. 尽量不要覆写基类的方法

&emsp;&emsp;这里使用的词也是尽量，我们这里是覆写基类方法，说明是覆盖重写抽象类的方法（接口叫实现），在实际项目中尽量不要去重写基类方法，因为基类方法可能已经在项目的各个地方运行，涉及到业务逻辑的执行，你重写可能会对系统稳定造成影响。



##### 5. 结合里氏替换原则使用

&emsp;&emsp;里氏替换原则在这里就不多说了，能使用父类的地方尽量不要使用子类。可以查看 《里氏替换原则》博客部分。